# Traffic Manager

- [__Traffic Manager란?__](#traffic-manager란)
    - [구조적 설계](#구조적-설계)
    - [사용자 커스터마이징](#사용자-커스터마이징)
- [__아키텍처__](#아키텍처)
    - [개요](#개요)
    - [ALSM](#alsm)
    - [차량 레지스트리](#차량-레지스트리)
    - [시뮬레이션 상태](#시뮬레이션-상태)
    - [제어 루프](#제어-루프)
    - [인메모리 맵](#인메모리-맵)
    - [PBVT](#pbvt)
    - [PID 컨트롤러](#pid-컨트롤러)
    - [명령어 배열](#명령어-배열)
    - [제어 루프의 단계들](#제어-루프의-단계들)
- [__Traffic Manager 사용하기__](#traffic-manager-사용하기)
    - [차량 행동 고려사항](#차량-행동-고려사항)
    - [Traffic Manager 생성](#traffic-manager-생성)
    - [자동조종 동작 설정](#자동조종-동작-설정)
    - [Traffic Manager 중지](#traffic-manager-중지)

---
## Traffic Manager란?

Traffic Manager(TM)는 시뮬레이션에서 자동조종 모드의 차량을 제어하는 모듈입니다. 이의 목표는 시뮬레이션에 현실적인 도시 교통 상황을 구현하는 것입니다. 사용자는 특정 학습 상황을 설정하는 등 일부 동작을 커스터마이즈할 수 있습니다.

### 구조적 설계

TM은 CARLA의 클라이언트 측에 구축되어 있습니다. 실행 흐름은 각각 독립적인 작업과 목표를 가진 **단계들**로 나뉩니다. 이는 단계 관련 기능과 데이터 구조의 개발을 용이하게 하면서 계산 효율성을 향상시킵니다. 각 단계는 다른 스레드에서 실행됩니다. 다른 단계와의 통신은 동기식 메시징을 통해 관리됩니다. 정보는 한 방향으로 흐릅니다.

### 사용자 커스터마이징

사용자는 특정 동작을 허용, 강제 또는 장려하는 매개변수를 설정하여 교통 흐름을 어느 정도 제어할 수 있습니다. 사용자는 자신이 선호하는 대로 교통 동작을 온라인과 오프라인 모두에서 변경할 수 있습니다. 예를 들어, 차량이 속도 제한을 무시하도록 허용하거나 차선 변경을 강제할 수 있습니다. 현실을 시뮬레이션하려고 할 때 동작을 조정할 수 있다는 점은 필수적입니다. 운전 시스템은 특정하고 비정형적인 상황에서 훈련되어야 합니다.
---
## 아키텍처

### 개요

![아키텍처](img/tm_2_architecture.jpg)

위의 다이어그램은 TM의 내부 아키텍처를 나타낸 것입니다. 각 구성 요소의 C++ 코드는 `LibCarla/source/carla/trafficmanager`에서 찾을 수 있습니다. 각 구성 요소는 다음 섹션에서 자세히 설명됩니다. 로직의 단순화된 개요는 다음과 같습니다:

__1. 시뮬레이션의 현재 상태를 저장하고 업데이트합니다.__

- [에이전트 수명 주기 및 상태 관리](#alsm)(ALSM)는 월드를 스캔하여 존재하는 모든 차량과 보행자를 추적하고 더 이상 존재하지 않는 항목에 대한 항목을 정리합니다. 모든 데이터는 서버에서 검색되어 여러 [단계](#제어-루프의-단계들)를 거칩니다. ALSM은 서버에 호출을 하는 유일한 구성 요소입니다.
- [차량 레지스트리](#차량-레지스트리)는 자동조종 상태의 차량(TM이 제어하는)의 배열과 자동조종이 아닌 보행자와 차량(TM이 제어하지 않는)의 목록을 포함합니다.
- [시뮬레이션 상태](#시뮬레이션-상태)는 시뮬레이션의 모든 차량과 보행자의 위치, 속도 및 추가 정보를 캐시 저장합니다.

__2. 모든 자동조종 차량의 이동을 계산합니다.__

TM은 [시뮬레이션 상태](#시뮬레이션-상태)에 따라 [차량 레지스트리](#차량-레지스트리)의 모든 차량에 대한 실행 가능한 명령을 생성합니다. 각 차량에 대한 계산은 별도로 수행됩니다. 이러한 계산은 서로 다른 [단계](#제어-루프의-단계들)로 나뉩니다. [제어 루프](#제어-루프)는 단계 사이에 **동기화 장벽**을 만들어 모든 계산이 일관되도록 합니다. 현재 단계의 모든 차량에 대한 계산이 완료되기 전에는 어떤 차량도 다음 단계로 이동하지 않습니다. 각 차량은 다음 단계를 거칩니다:

>__2.1 - [위치 파악 단계](#단계-1-위치-파악-단계).__

>[인메모리 맵](#인메모리-맵)에서 수집된 근처 웨이포인트 목록을 사용하여 경로가 동적으로 생성됩니다. 이는 시뮬레이션 맵을 웨이포인트 그리드로 단순화한 것입니다. 교차로에서의 방향은 무작위로 선택됩니다. 각 차량의 경로는 [경로 버퍼 및 차량 추적](#pbvt)(PBVT) 구성 요소에 저장되고 유지되어 향후 단계에서 쉽게 접근하고 수정할 수 있습니다.

>__2.2 - [충돌 단계](#단계-2-충돌-단계).__

>각 차량의 경로 위에 경계 상자를 확장하여 잠재적인 충돌 위험을 식별하고 회피합니다.

>__2.3 - [신호등 단계](#단계-3-신호등-단계).__

>충돌 단계와 유사하게, 신호등, 정지 표지판, 교차로 우선순위로 인해 각 차량의 경로에 영향을 미치는 잠재적 위험을 식별합니다.

>__2.4 - [모션 플래너 단계](#단계-4-모션-플래너-단계).__

>정의된 경로에 따라 차량 이동을 계산합니다. [PID 컨트롤러](#pid-컨트롤러)가 목표 웨이포인트에 도달하는 방법을 결정합니다. 이는 다음 단계에서 적용할 CARLA 명령으로 변환됩니다.

>__2.5 - [차량 조명 단계](#단계-5-차량-조명-단계).__

>환경 요인(예: 햇빛과 안개 또는 비의 존재)과 차량 동작(예: 다음 교차로에서 좌/우회전할 경우 방향 지시등을 켜거나 제동 시 정지등을 켜는 등)에 따라 차량 조명이 동적으로 켜지거나 꺼집니다.

__3. 시뮬레이션에 명령을 적용합니다.__

이전 단계에서 생성된 명령은 [명령어 배열](#명령어-배열)에 수집되어 동일한 프레임에 적용되도록 CARLA 서버로 일괄 전송됩니다.

다음 섹션에서는 위에서 설명한 TM 로직의 각 구성 요소와 단계를 더 자세히 설명합니다.
### ALSM

ALSM은 __Agent Lifecycle and State Management__(에이전트 수명 주기 및 상태 관리)의 약자입니다. 이는 TM 로직 사이클의 첫 번째 단계이며 시뮬레이션의 현재 상태에 대한 맥락을 제공합니다.

ALSM 구성 요소는:

- 월드를 스캔하여 모든 차량과 보행자, 그들의 위치와 속도를 추적합니다. 물리가 활성화된 경우 속도는 [Vehicle.get_velocity()](python_api.md#carla.Vehicle)를 통해 검색됩니다. 그렇지 않으면 시간에 따른 위치 업데이트 기록을 사용하여 속도가 계산됩니다.
- 모든 차량과 보행자의 위치, 속도 및 추가 정보(신호등 영향, 경계 상자 등)를 [시뮬레이션 상태](#시뮬레이션-상태) 구성 요소에 저장합니다.
- [차량 레지스트리](#차량-레지스트리)에서 TM이 제어하는 차량 목록을 업데이트합니다.
- [제어 루프](#제어-루프)와 [PBVT](#pbvt) 구성 요소의 항목을 차량 레지스트리와 일치하도록 업데이트합니다.

__관련 .cpp 파일:__ `ALSM.h`, `ALSM.cpp`.

### 차량 레지스트리

차량 레지스트리는 시뮬레이션의 모든 차량과 보행자를 추적합니다.

차량 레지스트리는:

- [ALSM](#alsm)으로부터 업데이트된 차량 및 보행자 목록을 전달받습니다.
- TM에 등록된 차량을 [제어 루프](#제어-루프) 동안 반복할 수 있도록 별도의 배열에 저장합니다.

__관련 .cpp 파일:__ `MotionPlannerStage.cpp`.

### 시뮬레이션 상태

시뮬레이션 상태는 나중 단계에서 쉽게 접근하고 수정할 수 있도록 시뮬레이션의 모든 차량에 대한 정보를 저장합니다.

시뮬레이션 상태는:

- [ALSM](#alsm)으로부터 현재 액터 위치, 속도, 신호등 영향, 신호등 상태 등을 포함한 데이터를 받습니다.
- [제어 루프](#제어-루프) 동안 서버에 추가 호출을 하지 않도록 모든 정보를 캐시에 저장합니다.

__관련 .cpp 파일:__ `SimulationState.cpp`, `SimulationState.h`.

### 제어 루프

제어 루프는 모든 자동조종 차량의 다음 명령 계산이 동기적으로 수행되도록 관리합니다. 제어 루프는 위치 파악, 충돌, 신호등, 모션 플래너, 차량 조명의 다섯 가지 서로 다른 [단계](#제어-루프의-단계들)로 구성됩니다.

제어 루프는:

- [차량 레지스트리](#차량-레지스트리)로부터 TM이 제어하는 차량의 배열을 받습니다.
- 배열을 반복하여 각 차량에 대해 별도로 계산을 수행합니다.
- 계산을 일련의 [단계들](#제어-루프의-단계들)로 나눕니다.
- 일관성을 보장하기 위해 단계 사이에 동기화 장벽을 만듭니다. 모든 차량의 계산이 완료되기 전에는 다음 단계로 넘어가지 않으므로, 모든 차량이 동일한 프레임에서 업데이트됩니다.
- 모든 계산이 동기적으로 수행되도록 [단계](#제어-루프의-단계들) 간의 전환을 조정합니다.
- 마지막 단계들([모션 플래너 단계](#단계-4-모션-플래너-단계)와 [차량 조명 단계](#단계-5-차량-조명-단계))이 완료되면 명령 계산과 명령 적용 사이에 프레임 지연이 없도록 [명령어 배열](#명령어-배열)을 서버로 보냅니다.

__관련 .cpp 파일:__ `TrafficManagerLocal.cpp`.
### 인메모리 맵

인메모리 맵은 [PBVT](#pbvt) 내에 포함된 헬퍼 모듈이며 [위치 파악 단계](#단계-1-위치-파악-단계) 동안 사용됩니다.

인메모리 맵은:

- 맵을 이산적인 웨이포인트의 그리드로 변환합니다.
- 웨이포인트를 연결하고 도로, 교차로 등을 식별하기 위한 더 많은 정보가 포함된 특정 데이터 구조에 웨이포인트를 포함합니다.
- 근처 영역의 차량을 빠르게 찾는 데 사용되는 ID로 이러한 구조를 식별합니다.

__관련 .cpp 파일:__ `InMemoryMap.cpp`와 `SimpleWaypoint.cpp`.

### PBVT

PBVT는 __Path Buffer and Vehicle Tracking__(경로 버퍼 및 차량 추적)의 약자입니다. PBVT는 모든 차량의 예상 경로를 포함하는 데이터 구조이며 [제어 루프](#제어-루프) 동안 데이터에 쉽게 접근할 수 있게 합니다.

PBVT는:

- 차량당 하나의 항목이 있는 데크(deque) 객체의 맵을 포함합니다.
- 각 차량의 현재 위치와 가까운 미래의 경로를 설명하는 웨이포인트 세트를 포함합니다.
- [위치 파악 단계](#단계-1-위치-파악-단계)에서 모든 차량을 가장 가까운 웨이포인트와 가능한 겹치는 경로에 연결하는 데 사용되는 [인메모리 맵](#인메모리-맵)을 포함합니다.

### PID 컨트롤러

PID 컨트롤러는 [모션 플래너 단계](#단계-4-모션-플래너-단계) 동안 계산을 수행하는 헬퍼 모듈입니다.

PID 컨트롤러는:

- [모션 플래너 단계](#단계-4-모션-플래너-단계)에서 수집한 정보를 사용하여 목표값에 도달하는 데 필요한 스로틀, 브레이크, 조향 입력을 추정합니다.
- 컨트롤러의 특정 매개변수화에 따라 조정을 합니다. 필요한 경우 매개변수를 수정할 수 있습니다. [PID 컨트롤러](https://en.wikipedia.org/wiki/PID_controller)에 대해 자세히 읽어보고 수정 방법을 알아보세요.

__관련 .cpp 파일:__ `PIDController.cpp`.

### 명령어 배열

명령어 배열은 TM 로직 사이클의 마지막 단계를 나타냅니다. 등록된 모든 차량에 대한 명령을 받아 적용합니다.

명령어 배열은:

- [모션 플래너 단계](#단계-4-모션-플래너-단계)로부터 [carla.VehicleControl](python_api.md#carla.VehicleControl)의 시리즈를 받습니다.
- 동일한 프레임에 적용될 모든 명령을 일괄 처리합니다.
- [carla.Client](../python_api/#carla.Client)의 시뮬레이션이 비동기 또는 동기 모드로 실행되는지에 따라 각각 __apply_batch()__ 또는 __apply_batch_synch()__를 호출하여 일괄 처리된 명령을 CARLA 서버로 보냅니다.

__관련 .cpp 파일:__ `TrafficManagerLocal.cpp`.
### 제어 루프의 단계들

##### 단계 1- 위치 파악 단계

위치 파악 단계는 TM이 제어하는 차량의 가까운 미래 경로를 정의합니다.

위치 파악 단계는:

- [시뮬레이션 상태](#시뮬레이션-상태)에서 모든 차량의 위치와 속도를 얻습니다.
- [인메모리 맵](#인메모리-맵)을 사용하여 각 차량을 궤적에 따른 현재 위치와 가까운 미래 경로를 설명하는 웨이포인트 목록과 연결합니다. 차량이 빠를수록 목록이 더 길어집니다.
- 차선 변경, 속도 제한, 선행 차량과의 거리 매개변수화 등과 같은 계획 결정에 따라 경로를 업데이트합니다.
- 모든 차량의 경로를 [PBVT](#pbvt) 모듈에 저장합니다.
- 가능한 충돌 상황을 추정하기 위해 경로들을 서로 비교합니다. 결과는 충돌 단계로 전달됩니다.

__관련 .cpp 파일:__ `LocalizationStage.cpp`와 `LocalizationUtils.cpp`.

##### 단계 2- 충돌 단계

충돌 단계는 충돌 위험을 트리거합니다.

충돌 단계는:

- [위치 파악 단계](#단계-1-위치-파악-단계)로부터 경로가 잠재적으로 겹칠 수 있는 차량 쌍의 목록을 받습니다.
- 각 차량 쌍에 대해 경로를 따라 경계 상자를 확장하여(측지선 경계) 실제로 겹치는지 확인하고 충돌 위험이 실제인지 판단합니다.
- 가능한 모든 충돌에 대한 위험을 [모션 플래너 단계](#단계-4-모션-플래너-단계)로 보내 그에 따라 경로를 수정합니다.

__관련 .cpp 파일:__ `CollisionStage.cpp`.

##### 단계 3- 신호등 단계

신호등 단계는 신호등, 정지 표지판, 교차로 우선순위와 같은 교통 규제로 인한 위험을 트리거합니다.

신호등 단계는:

- 차량이 황색이나 적색 신호등 또는 정지 표지판의 영향을 받는 경우 교통 위험을 설정합니다.
- 차량이 신호가 없는 교차로에 있는 경우 해당 차량의 경로를 따라 경계 상자를 확장합니다. 경로가 겹치는 차량들은 "선입선출" 순서에 따라 이동합니다. 대기 시간은 고정 값으로 설정됩니다.

__관련 .cpp 파일:__ `TrafficLightStage.cpp`.

##### 단계 4- 모션 플래너 단계

모션 플래너 단계는 차량에 적용할 CARLA 명령을 생성합니다.

모션 플래너 단계는:

- 차량의 위치와 속도([시뮬레이션 상태](#시뮬레이션-상태)), 경로([PBVT](#pbvt)), 그리고 위험([충돌 단계](#단계-2-충돌-단계)와 [신호등 단계](#단계-3-신호등-단계))을 수집합니다.
- 예를 들어 충돌 위험을 방지하기 위해 필요한 제동을 계산하는 등, 차량이 어떻게 움직여야 하는지에 대한 고수준 결정을 내립니다. 목표 값에 따른 동작을 추정하기 위해 [PID 컨트롤러](#pid-컨트롤러)가 사용됩니다.
- 원하는 움직임을 차량에 적용할 [carla.VehicleControl](python_api.md#carla.VehicleControl)로 변환합니다.
- 결과로 나온 CARLA 명령을 [명령어 배열](#명령어-배열)로 보냅니다.

__관련 .cpp 파일:__ `MotionPlannerStage.cpp`.

##### 단계 5- 차량 조명 단계

차량 조명 단계는 차량의 상태와 주변 환경에 따라 조명을 활성화합니다.

차량 조명 단계는:

- 차량의 계획된 웨이포인트, 차량 조명 정보(예: 조명 상태와 적용될 계획된 명령) 및 날씨 조건을 검색합니다.

- 차량 조명의 새로운 상태를 결정합니다:
  - 차량이 다음 교차로에서 좌/우회전할 계획이면 방향 지시등을 켭니다.
  - 적용된 명령이 차량에 제동을 요구하면 정지등을 켭니다.
  - 일몰부터 새벽까지 또는 폭우 시에 하향등과 위치등을 켭니다.
  - 짙은 안개 상태에서 안개등을 켭니다.

- 변경이 있었다면 차량 조명 상태를 업데이트합니다.

__관련 .cpp 파일:__ `VehicleLightStage.cpp`.
---
## Traffic Manager 사용하기

### 차량 행동 고려사항

TM은 차량을 자동조종으로 설정할 때 고려해야 하는 일반적인 행동 패턴을 구현합니다:

- __차량은 목표 지향적이지 않습니다.__ 차량들은 동적으로 생성된 궤적을 따르며 교차로에 접근할 때 무작위로 경로를 선택합니다. 이들의 경로는 끝이 없습니다.
- __차량의 목표 속도는 현재 속도 제한의 70%입니다.__ 다른 값이 설정되지 않는 한 이 값을 사용합니다.
- __교차로 우선순위는 교통 규정을 따르지 않습니다.__ TM은 교차로에서 자체적인 우선순위 시스템을 사용합니다. 이 제한 사항의 해결은 진행 중입니다. 그동안 일부 문제가 발생할 수 있습니다. 예를 들어, 로터리 안에 있는 차량이 진입하려는 차량에게 양보하는 경우가 있습니다.

TM 행동은 Python API를 통해 조정할 수 있습니다. 특정 메서드에 대해서는 API [문서](../python_api/#carla.TrafficManager)의 TM 섹션을 참조하세요. 아래는 API를 통해 가능한 것들의 일반적인 요약입니다:

| 주제 | 설명 |
| ----- | ----------- |
| **일반:** | - 포트에 연결된 TM 인스턴스 생성. <br> - TM이 연결된 포트 검색. |
| **안전 조건:** | - 정지된 차량 사이의 최소 거리 설정(단일 차량 또는 모든 차량에 대해). 이는 최소 이동 거리에 영향을 미칩니다. <br> - 현재 속도 제한의 백분율로 원하는 속도 설정(단일 차량 또는 모든 차량에 대해). <br> - 신호등 재설정. |
| **충돌 관리:** | - 차량과 특정 액터 사이의 충돌 활성화/비활성화. <br> - 차량이 다른 모든 차량을 무시하도록 설정. <br> - 차량이 모든 보행자를 무시하도록 설정. <br> - 차량이 모든 신호등을 무시하도록 설정. |
| **차선 변경:** | - 가능한 충돌을 무시하고 차선 변경 강제. <br> - 차량의 차선 변경 활성화/비활성화. |
| **하이브리드 물리 모드:** | - 하이브리드 물리 모드 활성화/비활성화. <br> - 물리가 활성화되는 반경 변경. |
네, 공식 문서 MD 파일을 제공해 주시면 훌륭한 기술적 번역을 해드리겠습니다. 번역된 MD 파일을 아래와 같이 자연스럽고 기술적으로 표현된 한국어로 출력하겠습니다.

### Traffic Manager 생성하기

!!! Note
    TM은 동기 모드에서 작동하도록 설계되었습니다. TM을 비동기 모드에서 사용하면 예기치 않은 결과가 발생할 수 있습니다. [__동기 모드__](#동기-모드) 섹션에서 자세히 알아보세요.

TM 인스턴스는 [`carla.Client`](python_api.md#carla.Client)를 통해 사용할 포트를 전달하여 생성됩니다. 기본 포트는 `8000`입니다.

TM 인스턴스를 생성하려면 다음과 같이 합니다:

```python
tm = client.get_trafficmanager(port)
```

자동 조종 모드를 차량 집합에 활성화하려면 TM 인스턴스의 포트를 가져와서 `set_autopilot` 옵션을 `True`로 설정합니다. 포트를 지정하지 않으면 기본 포트(`8000`)에 연결하려 시도하며, TM이 존재하지 않는 경우 새로 생성합니다:

```python
tm_port = tm.get_port()
 for v in vehicles_list:
     v.set_autopilot(True,tm_port)
```
!!! Note 
    다중 클라이언트 상황에서 TM을 생성하거나 연결하는 방법은 위 예제와 다릅니다. [__다중 Traffic Manager 실행하기__](#다중-traffic-manager-실행하기)에서 자세히 알아보세요.

`generate_traffic.py` 스크립트 `/PythonAPI/examples`에서는 스크립트 인수로 전달된 포트를 사용하여 TM 인스턴스를 생성하고, 생성된 모든 차량에 자동 조종 모드를 설정하는 예제를 보여줍니다:

```py
traffic_manager = client.get_trafficmanager(args.tm-port)
tm_port = traffic_manager.get_port()
...
batch.append(SpawnActor(blueprint, transform).then(SetAutopilot(FutureActor, True,tm_port)))
...
traffic_manager.global_percentage_speed_difference(30.0)
```

### 자동 조종 동작 구성하기

다음 예에서는 TM 인스턴스를 생성하고, 특정 차량의 위험한 동작을 구성합니다. 이 차량은 모든 신호등을 무시하고, 다른 차량과 안전 거리를 유지하지 않으며, 현재 속도 제한보다 20% 빠르게 운전합니다:

```python
tm = client.get_trafficmanager(port)
tm_port = tm.get_port()
for v in my_vehicles:
  v.set_autopilot(True,tm_port)
danger_car = my_vehicles[0]
tm.ignore_lights_percentage(danger_car,100)
tm.distance_to_leading_vehicle(danger_car,0)
tm.vehicle_percentage_speed_difference(danger_car,-20)
``` 

다음 예에서는 같은 차량 집합에 자동 조종 모드를 설정하지만, 적절한 운전 동작을 구성합니다. 차량은 현재 속도 제한보다 80% 느리게 주행하고, 다른 차량과 최소 5미터의 거리를 유지하며, 차선 변경을 수행하지 않습니다:

```python
tm = client.get_trafficmanager(port)
tm_port = tm.get_port()
for v in my_vehicles:
  v.set_autopilot(True,tm_port)
danger_car = my_vehicles[0]
tm.global_distance_to_leading_vehicle(5)
tm.global_percentage_speed_difference(80)
for v in my_vehicles: 
  tm.auto_lane_change(v,False)
``` 

#### 차량 조명 자동 업데이트를 TM에 위임하기

기본적으로 TM에 의해 관리되는 차량의 조명(브레이크, 방향 지시등 등)은 업데이트되지 않습니다. 특정 차량 액터의 조명 업데이트를 TM에 위임할 수 있습니다:

```python
tm = client.get_trafficmanager(port)
for actor in my_vehicles:
  tm.update_vehicle_lights(actor, True)
```

차량 조명 관리는 차량별로 지정해야 하며, 언제든 자동 조명 관리가 활성화된 차량과 그렇지 않은 차량이 혼재될 수 있습니다.


### Traffic Manager 중지하기

TM은 소멸해야 하는 액터가 아니며, 이를 생성한 클라이언트가 중지되면 자동으로 중지됩니다. 이는 API에 의해 자동으로 관리되므로 사용자가 별도의 작업을 할 필요가 없습니다. 그러나 TM을 종료할 때는 이를 통해 관리되는 차량을 반드시 소멸시켜야 합니다. 그렇지 않으면 지도 위에 정지된 상태로 남게 됩니다. `generate_traffic.py` 스크립트는 이 작업을 자동으로 수행합니다:

```py
client.apply_batch([carla.command.DestroyActor(x) for x in vehicles_list])
```

!!! Warning
    **TM-Server**를 종료하면 이에 연결된 **TM-Client**들도 함께 종료됩니다. **TM-Server**와 **TM-Client**의 차이점에 대해 알아보려면 [__다중 Traffic Manager 실행하기__](#다중-traffic-manager-실행하기)를 읽어보세요.

---
## 결정론 모드

결정론 모드에서 TM은 동일한 조건에서 항상 동일한 결과와 동작을 생성합니다. 이를 기록기와 혼동하지 마세요. 기록기는 시뮬레이션 로그를 저장하고 재생할 수 있는 반면, 결정론은 동일한 조건이 유지되는 한 TM이 항상 동일한 출력을 내도록 보장합니다.

결정론 모드는 __동기 모드__에서만 사용 가능합니다. 비동기 모드에서는 시뮬레이션에 대한 제어력이 부족하여 결정론을 달성할 수 없습니다. [__"동기 모드"__](#동기-모드) 섹션을 읽고 시작하세요.

결정론 모드를 활성화하려면 다음 메서드를 사용하세요:

```py
my_tm.set_random_device_seed(seed_value)
```

`seed_value`는 무작위 숫자 생성을 위한 `int` 값입니다. 값 자체는 중요하지 않지만, 동일한 값을 사용하면 항상 동일한 출력이 생성됩니다. 동일한 조건에서 동일한 시드 값을 사용하는 두 시뮬레이션은 결정론적입니다.

여러 시뮬레이션 실행에 걸쳐 결정론을 유지하려면 __매 시뮬레이션마다 시드를 설정해야 합니다__. 예를 들어, 세계가 [다시 로드](python_api.md#carla.Client.reload_world)될 때마다 시드를 다시 설정해야 합니다:

```py
client.reload_world()
my_tm.set_random_device_seed(seed_value)
```

결정론 모드는 `generate_traffic.py` 예제 스크립트에서 시드 값을 인수로 전달하여 테스트할 수 있습니다. 다음 예제는 동기 모드에서 50개의 자동 조종 액터로 맵을 채우고, 임의의 값 `9`를 시드로 설정합니다:

```sh
cd PythonAPI/examples
python3 generate_traffic.py -n 50 --seed 9
```

!!! Warning
    CARLA 서버와 TM은 결정론 모드를 활성화하기 전에 동기 모드로 설정되어 있어야 합니다. [여기](#동기-모드)에서 TM의 동기 모드에 대해 자세히 알아보세요.

---
## 하이브리드 물리 모드

하이브리드 모드를 사용하면 사용자가 모든 자동 조종 차량의 물리 계산을 비활성화하거나, "영웅" 차량에서 일정 반경 내의 자동 조종 차량의 물리 계산을 비활성화할 수 있습니다. 이렇게 하면 시뮬레이션의 차량 물리 처리 병목 현상을 제거할 수 있습니다. 물리 계산이 비활성화된 차량은 순간 이동 방식으로 움직입니다. 선형 가속도에 대한 기본 계산은 유지되어 위치 업데이트와 차량 속도가 현실적이며, 물리 계산 전환이 부드럽습니다.

하이브리드 모드는 [`Actor.set_simulate_physics()`](https://carla.readthedocs.io/en/latest/python_api/#carla.Actor.set_simulate_physics) 메서드를 사용하여 물리 계산을 전환합니다. 기본적으로 비활성화되어 있으며, 다음 두 가지 옵션으로 활성화할 수 있습니다:

*   [__`TrafficManager.set_hybrid_physics_mode(True)`__](https://carla.readthedocs.io/en/latest/python_api/#carla.TrafficManager.set_hybrid_physics_mode) — 이 메서드는 호출하는 TM 객체에 대해 하이브리드 모드를 활성화합니다.
*   __`generate_traffic.py` 스크립트에 `--hybrid` 플래그 실행__ — 이 예제 스크립트는 TM을 생성하고 자동 조종 차량을 생성합니다. `--hybrid` 플래그가 전달되면 이 차량들을 하이브리드 모드로 설정합니다.

하이브리드 모드의 동작을 수정하려면 다음 두 가지 매개변수를 사용하세요:

*   __반경__ *(기본값 = 50미터)* — 이 반경은 "영웅" 차량을 기준으로 합니다. 이 반경 내의 모든 차량은 물리 계산이 활성화되며, 반경 밖의 차량은 물리 계산이 비활성화됩니다. 반경 크기는 [`traffic_manager.set_hybrid_physics_radius(r)`](python_api.md#carla.TrafficManager.set_hybrid_physics_radius)를 사용하여 수정할 수 있습니다.
*   __영웅 차량__ — `role_name='hero'`로 태그된 차량이 반경의 중심이 됩니다.
	*   __영웅 차량이 없는 경우,__ 모든 차량의 물리 계산이 비활성화됩니다.
	*   __영웅 차량이 둘 이상인 경우,__ 각각의 영향 반경이 고려됩니다.

다음 클립은 하이브리드 모드가 활성화되었을 때 물리 계산이 활성화/비활성화되는 모습을 보여줍니다. **영웅 차량**은 **빨간색 사각형**으로 표시됩니다. 물리 계산이 __비활성화된__ 차량은 **파란색 사각형**으로 표시됩니다. 영웅 차량의 반경 내에 있는 차량은 **물리 계산이 활성화되어 녹색 태그**가 지정됩니다.

![Welcome to CARLA](img/tm_hybrid.gif)
---

### 다중 Traffic Manager 실행하기

###### TM-Server

TM-Server는 포트가 비어있는 상태에서 최초로 연결된 TM이 됩니다. TM-Server는 연결된 모든 TM-Client의 동작을 결정합니다. 예를 들어 TM-Server가 중지되면 모든 TM-Client도 함께 중지됩니다.

다음 코드는 두 개의 TM-Server를 생성합니다. 각각 다른 사용되지 않은 포트에 연결됩니다:

```py 
tm01 = client01.get_trafficmanager() # tm01 --> tm01 (p=8000)
```
```py
tm02 = client02.get_trafficmanager(5000) # tm02(p=5000) --> tm02 (p=5000)
```

###### TM-Client

TM-Client는 다른 TM(TM-Server)이 이미 연결되어 있는 포트에 연결될 때 생성됩니다. TM-Client의 동작은 TM-Server에 의해 결정됩니다.

다음 코드는 두 개의 TM-Client를 생성합니다. 각각 위에서 생성된 TM-Server에 연결됩니다.

```py
tm03 = client03.get_trafficmanager() # tm03 --> tm01 (p=8000). 
```
```py
tm04 = client04.get_trafficmanager(5000) # tm04(p=5000) --> tm02 (p=5000)
```

CARLA 서버는 모든 TM 인스턴스의 포트와 클라이언트 IP(사용자에게 숨겨짐)를 저장하여 관리합니다. 지금까지 생성된 TM 인스턴스를 확인할 방법은 없습니다. 인스턴스 생성을 시도하면 항상 연결이 시도되며, 새로운 __TM-Server__ 또는 __TM-Client__가 생성됩니다.

### 다중 클라이언트 시뮬레이션

다중 클라이언트 시뮬레이션에서는 동일한 포트에 여러 TM이 생성됩니다. 첫 번째 TM은 TM-Server가 되고, 나머지는 이 TM-Server에 연결되는 TM-Client가 됩니다. TM-Server가 모든 TM 인스턴스의 동작을 결정합니다:

```py
terminal 1: ./CarlaUE4.sh -carla-rpc-port=4000
terminal 2: python3 generate_traffic.py --port 4000 --tm-port 4050 # TM-Server
terminal 3: python3 generate_traffic.py --port 4000 --tm-port 4050 # TM-Client
```

### 다중 TM 시뮬레이션

다중 TM 시뮬레이션에서는 서로 다른 포트에 여러 TM 인스턴스가 생성됩니다. 각 TM 인스턴스는 자체적인 동작을 제어합니다:

```py
terminal 1: ./CarlaUE4.sh -carla-rpc-port=4000
terminal 2: python3 generate_traffic.py --port 4000 --tm-port 4050 # TM-Server A
terminal 3: python3 generate_traffic.py --port 4000 --tm-port 4550 # TM-Server B
```

### 다중 시뮬레이션

다중 시뮬레이션은 둘 이상의 CARLA 서버가 동시에 실행되는 경우입니다. TM은 관련 CARLA 서버 포트에 연결해야 합니다. 컴퓨팅 파워가 허용한다면 TM은 동시에 여러 시뮬레이션을 실행할 수 있습니다:

```py
terminal 1: ./CarlaUE4.sh -carla-rpc-port=4000 # simulation A 
terminal 2: ./CarlaUE4.sh -carla-rpc-port=5000 # simulation B
terminal 3: python3 generate_traffic.py --port 4000 --tm-port 4050 # TM-Server A connected to simulation A
terminal 4: python3 generate_traffic.py --port 5000 --tm-port 5050 # TM-Server B connected to simulation B
```

다중 시뮬레이션 개념은 TM 자체와 독립적입니다. 위의 예에서는 A와 B라는 두 개의 CARLA 시뮬레이션이 병렬로 실행됩니다. 각 시뮬레이션에서 TM-Server가 독립적으로 생성됩니다. A 시뮬레이션에서 다중 클라이언트 TM을 실행할 수 있고, B 시뮬레이션에서는 다중 TM 또는 TM 없이 실행할 수 있습니다.

위와 같은 설정에서 발생할 수 있는 가장 큰 문제는 이미 존재하는 TM에 연결하려는 클라이언트가 실제로는 다른 시뮬레이션에서 실행 중인 TM에 연결하려는 경우입니다. 이 경우 오류 메시지가 나타나고 시뮬레이션 간 간섭을 방지하기 위해 연결이 중단됩니다.

---
## 동기 모드

TM은 동기 모드에서 작동하도록 설계되었습니다. CARLA 서버와 TM 모두 동기 모드로 설정되어 있어야 올바르게 작동합니다. __TM을 비동기 모드에서 사용하면 예기치 않은 결과가 발생할 수 있습니다.__ 그러나 비동기 모드가 필요한 경우 시뮬레이션은 최소 20-30 fps로 실행되어야 합니다.

다음 스크립트는 서버와 TM을 동기 모드로 설정하는 방법을 보여줍니다:

```py
...

# 시뮬레이션을 동기 모드로 설정
init_settings = world.get_settings()
settings = world.get_settings()
settings.synchronous_mode = True
# 그 다음 TM을 동기 모드로 설정
my_tm.set_synchronous_mode(True)

...

# 동기화를 완료하려면 동일한 클라이언트에서 세계를 업데이트
world.apply_settings(init_settings)
world.tick()
...

# 스크립트 종료 전에 반드시 동기 모드를 비활성화하여 서버가 틱을 기다리는 것을 막아야 합니다.
settings.synchronous_mode = False
my_tm.set_synchronous_mode(False)
```

`generate_traffic.py` 예제 스크립트는 TM을 시작하고 맵에 차량과 보행자를 생성합니다. 이때 자동으로 TM과 CARLA 서버를 동기 모드로 설정합니다:

```sh
cd PythonAPI/examples
python3 generate_traffic.py -n 50
```

비동기 모드가 필요한 경우 위 명령어에 `--async` 플래그를 추가하세요.

하나 이상의 TM이 동기 모드로 설정된 경우 동기화가 실패합니다. 문제를 방지하려면 다음 지침을 따르세요:

- __[다중 클라이언트](#다중-클라이언트-시뮬레이션)__ 상황에서는 **TM-Server**만 동기 모드로 설정해야 합니다.
- __[다중 TM](#다중-tm-시뮬레이션)__ 상황에서는 **한 개의 TM-Server**만 동기 모드로 설정해야 합니다.
- __[ScenarioRunner 모듈](https://carla-scenariorunner.readthedocs.io/en/latest/)__은 자동으로 TM을 실행합니다. ScenarioRunner 내의 TM은 자동으로 동기 모드로 설정됩니다.

!!! Warning
    스크립트가 종료되기 전에 (세계와 TM 모두) 동기 모드를 비활성화하여 서버가 영원히 틱을 기다리는 것을 방지해야 합니다.

---

## 대규모 맵에서의 Traffic Manager

대규모 맵에서 TM의 동작을 이해하려면 먼저 대규모 맵 작동 방식에 대해 숙지해야 합니다. [여기](large_map_overview.md)에서 관련 문서를 읽어보세요.

영웅 차량의 존재 여부에 따라 대규모 맵에서 자동 조종 차량의 동작이 달라집니다:

__영웅 차량이 없는 경우__

모든 자동 조종 차량이 휴면 액터로 간주됩니다. 휴면 자동 조종 차량은 하이브리드 모드와 같이 맵 주위로 이동됩니다. 영웅 차량이 없으므로 맵 타일 스트리밍이 트리거되지 않아 차량이 렌더링되지 않습니다.

__영웅 차량이 있는 경우__ 

`actor_active_distance` 값을 넘어서면 자동 조종 차량이 휴면 상태가 됩니다. 이 값을 설정하려면 Python API를 사용합니다:

```py
settings = world.get_settings()

# 에고 차량에서 2km 떨어지면 액터가 휴면 상태가 됩니다
settings.actor_active_distance = 2000

world.apply_settings(settings)
```

TM에서는 휴면 상태의 액터가 영웅 차량 주변에서 대신 계속 다시 생성되도록 구성할 수 있습니다. 이 옵션은 Python API의 `set_respawn_dormant_vehicles` 메서드를 사용하여 구성할 수 있습니다. 차량은 영웅 차량에서 사용자 정의 가능한 거리 내에서 다시 생성됩니다. 다시 생성할 수 있는 최소 및 최대 거리는 `set_boundaries_respawn_dormant_vehicles` 메서드를 사용하여 설정할 수 있습니다. 최대 거리는 대규모 맵의 타일 스트리밍 거리보다 크지 않아야 하며, 최소 거리는 20미터 이상이어야 합니다.

영웅 차량 주변 25미터와 700미터 사이에서 휴면 차량을 다시 생성하도록 설정하려면:

```py
my_tm.set_respawn_dormant_vehicles(True)
my_tm.set_boundaries_respawn_dormant_vehicles(25,700)
```

충돌로 인해 휴면 액터를 다시 생성할 수 없는 경우 TM은 다음 시뮬레이션 단계에서 다시 시도합니다.

휴면 차량을 다시 생성하지 않으면 그 동작은 하이브리드 모드 활성화 여부에 따라 달라집니다. 하이브리드 모드가 활성화된 경우 휴면 액터는 맵 주변으로 순간 이동합니다. 하이브리드 모드가 비활성화된 경우 휴면 액터의 물리 계산이 수행되지 않으며 더 이상 휴면 상태가 되지 않을 때까지 그대로 유지됩니다.

---

TM에 대한 질문이 있다면 [포럼](https://github.com/carla-simulator/carla/discussions)에 문의할 수 있습니다.

<div class="build-buttons">
<p>
<a href="https://github.com/carla-simulator/carla/discussions" target="_blank" class="btn btn-neutral" title="Go to the CARLA forum">
CARLA 포럼</a>
</p>
</div>
