// Copyright (c) 2017 Computer Vision Center (CVC) at the Universitat Autonoma
// de Barcelona (UAB).
//
// This work is licensed under the terms of the MIT license.
// For a copy, see <https://opensource.org/licenses/MIT>.

#pragma once

#include "carla/rpc/Location.h"
#include "carla/sensor/data/SemanticLidarData.h"
#include "carla/sensor/data/LidarData.h"

#include <cstdint>
#include <vector>

namespace carla {

namespace ros2 {
  class ROS2;
}

namespace sensor {

namespace s11n {
  class SurfaceNormalLidarSerializer;
  class SurfaceNormalLidarHeaderView;
}

namespace data {

  /// Helper class to store and serialize the data generated by a Lidar.
  ///
  /// The header of a Lidar measurement consists of an array of uint32_t's in
  /// the following layout
  ///
  ///    {
  ///      Horizontal angle (float),
  ///      Channel count,
  ///      Point count of channel 0,
  ///      ...
  ///      Point count of channel n,
  ///    }
  ///
  /// The points are stored in an array of floats
  ///
  ///    {
  ///      X0, Y0, Z0, I0, NX0, NY0, NZ0
  ///      ...
  ///      Xn, Yn, Zn, In, NXn, NYn, NZn
  ///    }
  ///

  class SurfaceNormalLidarDetection {
    public:
      geom::Location point;
      float intensity;
      geom::Vector3D surf_normal;

      SurfaceNormalLidarDetection() :
          point(0.0f, 0.0f, 0.0f), intensity{0.0f}, surf_normal(0.0f, 0.0f, 0.0f) { }
      SurfaceNormalLidarDetection(float x, float y, float z, float intensity, float nx, float ny, float nz) :
          point(x, y, z), intensity{intensity}, surf_normal(nx, ny, nz) { }
      SurfaceNormalLidarDetection(geom::Location p, float intensity, geom::Location surf_normal) :
          point(p), intensity{intensity}, surf_normal(surf_normal) { }
      void WritePlyHeaderInfo(std::ostream& out) const{
        out << "property float32 x\n" \
          "property float32 y\n" \
          "property float32 z\n" \
          "property float32 I\n" \
          "property float32 nx\n" \
          "property float32 ny\n" \
          "property float32 nz";
      }

      void WriteDetection(std::ostream& out) const{
        out << point.x << ' ' << point.y << ' ' << point.z << ' ' << intensity
                << ' ' << surf_normal.x << ' ' << surf_normal.y << ' ' << surf_normal.z;
      }
  };

  class SurfaceNormalLidarData : public SemanticLidarData{


  public: 
    explicit SurfaceNormalLidarData(uint32_t ChannelCount = 0u)
      : SemanticLidarData(ChannelCount) {
    }

    SurfaceNormalLidarData &operator=(SurfaceNormalLidarData &&) = default;

    ~SurfaceNormalLidarData() = default;

    virtual void ResetMemory(std::vector<uint32_t> points_per_channel) {
      DEBUG_ASSERT(GetChannelCount() > points_per_channel.size());
      std::memset(_header.data() + Index::SIZE, 0, sizeof(uint32_t) * GetChannelCount());

      uint32_t total_points = static_cast<uint32_t>(
          std::accumulate(points_per_channel.begin(), points_per_channel.end(), 0));

      _points.clear();
      _points.reserve(total_points * 7);
    }

    void WritePointSync(SurfaceNormalLidarDetection &detection) {
      _points.emplace_back(detection.point.x);
      _points.emplace_back(detection.point.y);
      _points.emplace_back(detection.point.z);
      _points.emplace_back(detection.intensity);
      _points.emplace_back(detection.surf_normal.x);
      _points.emplace_back(detection.surf_normal.y);
      _points.emplace_back(detection.surf_normal.z);
    }

    virtual void WritePointSync(LidarDetection &detection) {
      (void) detection;
      DEBUG_ASSERT(false);
    }

    virtual void WritePointSync(SemanticLidarDetection &detection) {
      (void) detection;
      DEBUG_ASSERT(false);
    }

  private:
    std::vector<float> _points;

    friend class s11n::SurfaceNormalLidarSerializer;
    friend class s11n::SurfaceNormalLidarHeaderView;
    friend class carla::ros2::ROS2;
  };

} // namespace s11n
} // namespace sensor
} // namespace carla

